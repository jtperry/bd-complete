use crate::command_tree::{Command, CommandTree, Flag};
use std::io::{self, Write};

const LICENSE_HEADER: &str = r#"# Copyright 2006 JT Perry
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License."#;

/// Generate a complete Bash completion script for the given command tree.
pub fn generate_bash_completion(tree: &CommandTree, out: &mut dyn Write) -> io::Result<()> {
    writeln!(out, "#!/usr/bin/env bash")?;
    writeln!(out, "{LICENSE_HEADER}")?;
    writeln!(out)?;
    writeln!(out, "# Bash completion for {}", tree.root.name)?;
    writeln!(out, "# Generated by bd-complete")?;
    writeln!(out)?;

    let func_name = format!("_{}", tree.root.name);

    // Generate the main completion function
    writeln!(out, "{func_name}() {{")?;
    writeln!(out, "    local cur prev words cword")?;
    writeln!(out, "    _init_completion || return")?;
    writeln!(out)?;

    // Build a case statement that walks the command tree
    generate_command_dispatch(tree, out)?;

    writeln!(out, "}}")?;
    writeln!(out)?;
    writeln!(
        out,
        "complete -F {func_name} {}",
        tree.root.name
    )?;

    Ok(())
}

fn generate_command_dispatch(tree: &CommandTree, out: &mut dyn Write) -> io::Result<()> {
    // We need to determine which subcommand the user is typing.
    // Walk words[1..cword-1] to find the deepest matching command.
    writeln!(out, "    # Walk the command tree to find the active subcommand")?;
    writeln!(out, "    local cmd_path=\"\"")?;
    writeln!(out, "    local i=1")?;
    writeln!(out, "    while [[ $i -lt $cword ]]; do")?;
    writeln!(out, "        case \"${{words[$i]}}\" in")?;

    // Collect all known subcommand names (and their sub-subcommands)
    let all_subcmds = collect_all_command_names(&tree.root);
    if !all_subcmds.is_empty() {
        let pattern = all_subcmds.join("|");
        writeln!(out, "            {pattern})")?;
        writeln!(out, "                cmd_path=\"${{cmd_path:+$cmd_path }}${{words[$i]}}\"")?;
        writeln!(out, "                ;;")?;
    }

    writeln!(out, "            *)")?;
    writeln!(out, "                ;;")?;
    writeln!(out, "        esac")?;
    writeln!(out, "        ((i++))")?;
    writeln!(out, "    done")?;
    writeln!(out)?;

    // Now dispatch based on cmd_path
    writeln!(out, "    case \"$cmd_path\" in")?;

    // Generate cases for each subcommand path
    generate_cases_recursive(&tree.root, "", &tree.global_flags, out)?;

    // Default: top-level completions
    writeln!(out, "        *)")?;
    generate_completions_for_command(
        &tree.root,
        &tree.global_flags,
        "            ",
        out,
    )?;
    writeln!(out, "            ;;")?;
    writeln!(out, "    esac")?;

    Ok(())
}

fn generate_cases_recursive(
    cmd: &Command,
    path: &str,
    global_flags: &[Flag],
    out: &mut dyn Write,
) -> io::Result<()> {
    for (name, subcmd) in &cmd.subcommands {
        let sub_path = if path.is_empty() {
            name.clone()
        } else {
            format!("{path} {name}")
        };

        // Also handle aliases
        let mut patterns = vec![sub_path.clone()];
        for alias in &subcmd.aliases {
            let alias_path = if path.is_empty() {
                alias.clone()
            } else {
                format!("{path} {alias}")
            };
            patterns.push(alias_path);
        }

        let pattern = patterns
            .iter()
            .map(|p| if p.contains(' ') { format!("\"{p}\"") } else { p.clone() })
            .collect::<Vec<_>>()
            .join("|");
        writeln!(out, "        {pattern})")?;
        generate_completions_for_command(subcmd, global_flags, "            ", out)?;
        writeln!(out, "            ;;")?;

        // Recurse into sub-subcommands
        if !subcmd.subcommands.is_empty() {
            generate_cases_recursive(subcmd, &sub_path, global_flags, out)?;
        }
    }
    Ok(())
}

fn generate_completions_for_command(
    cmd: &Command,
    global_flags: &[Flag],
    indent: &str,
    out: &mut dyn Write,
) -> io::Result<()> {
    // Check if completing a flag value (prev is a flag that takes a value)
    let flags_with_values: Vec<&Flag> = cmd
        .flags
        .iter()
        .chain(global_flags.iter())
        .filter(|f| f.value_type.is_some())
        .collect();

    if !flags_with_values.is_empty() {
        writeln!(out, "{indent}case \"$prev\" in")?;
        for flag in &flags_with_values {
            let mut flag_patterns = vec![format!("--{}", flag.long)];
            if let Some(s) = flag.short {
                flag_patterns.push(format!("-{s}"));
            }
            let pattern = flag_patterns.join("|");
            writeln!(out, "{indent}    {pattern})")?;
            // Generate value completions based on type
            generate_flag_value_completion(flag, indent, out)?;
            writeln!(out, "{indent}        return")?;
            writeln!(out, "{indent}        ;;")?;
        }
        writeln!(out, "{indent}esac")?;
    }

    // If current word starts with -, complete flags
    writeln!(out, "{indent}if [[ \"$cur\" == -* ]]; then")?;

    let all_flags: Vec<String> = cmd
        .flags
        .iter()
        .chain(global_flags.iter())
        .map(|f| format!("--{}", f.long))
        .collect();

    if !all_flags.is_empty() {
        let flag_list = all_flags.join(" ");
        writeln!(
            out,
            "{indent}    mapfile -t COMPREPLY < <(compgen -W \"{flag_list}\" -- \"$cur\")"
        )?;
    }

    writeln!(out, "{indent}    return")?;
    writeln!(out, "{indent}fi")?;

    // Otherwise, complete subcommands
    if !cmd.subcommands.is_empty() {
        let subcmd_names: Vec<String> = cmd
            .subcommands
            .keys()
            .cloned()
            .collect();
        let subcmd_list = subcmd_names.join(" ");
        writeln!(
            out,
            "{indent}mapfile -t COMPREPLY < <(compgen -W \"{subcmd_list}\" -- \"$cur\")"
        )?;
    }

    Ok(())
}

fn generate_flag_value_completion(flag: &Flag, indent: &str, out: &mut dyn Write) -> io::Result<()> {
    match flag.value_type.as_deref() {
        Some("string") | Some("strings") => {
            // For file-like flags, use file completion; otherwise just return empty
            if flag.long.contains("file") || flag.long.contains("path") || flag.long == "db" {
                writeln!(out, "{indent}        mapfile -t COMPREPLY < <(compgen -f -- \"$cur\")")?;
            } else {
                writeln!(out, "{indent}        COMPREPLY=()")?;
            }
        }
        Some("int") | Some("int32") | Some("int64") | Some("uint") | Some("float") | Some("float64") | Some("count") => {
            writeln!(out, "{indent}        COMPREPLY=()")?;
        }
        Some("duration") => {
            writeln!(out, "{indent}        COMPREPLY=()")?;
        }
        _ => {
            writeln!(out, "{indent}        COMPREPLY=()")?;
        }
    }
    Ok(())
}

/// Collect all command and subcommand names from the tree (for the word-walking case statement).
fn collect_all_command_names(cmd: &Command) -> Vec<String> {
    let mut names: Vec<String> = Vec::new();
    for (name, subcmd) in &cmd.subcommands {
        names.push(name.clone());
        for alias in &subcmd.aliases {
            names.push(alias.clone());
        }
        // Also add sub-subcommand names
        for sub_name in subcmd.subcommands.keys() {
            if !names.contains(sub_name) {
                names.push(sub_name.clone());
            }
        }
    }
    names.sort();
    names.dedup();
    names
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::command_tree::CommandGroup;

    fn sample_tree() -> CommandTree {
        let mut root = Command::new("bd", "A lightweight issue tracker");

        // Add some subcommands
        let mut show_cmd = Command::new("show", "Show issue details");
        show_cmd.flags.push(Flag {
            long: "format".to_string(),
            short: Some('f'),
            description: "Output format".to_string(),
            value_type: Some("string".to_string()),
            default: None,
        });

        let mut search_cmd = Command::new("search", "Search issues");
        search_cmd.flags.push(Flag {
            long: "query".to_string(),
            short: Some('q'),
            description: "Search query".to_string(),
            value_type: Some("string".to_string()),
            default: None,
        });

        let set_state_cmd = Command::new("set-state", "Set issue state");

        // Subcommand with sub-subcommands
        let mut dep_cmd = Command::new("dep", "Dependency management");
        dep_cmd.subcommands.insert(
            "add".to_string(),
            Command::new("add", "Add a dependency"),
        );
        dep_cmd.subcommands.insert(
            "remove".to_string(),
            Command::new("remove", "Remove a dependency"),
        );
        dep_cmd.subcommands.insert(
            "list".to_string(),
            Command::new("list", "List dependencies"),
        );

        // Command with alias
        let mut create_cmd = Command::new("create", "Create a new issue");
        create_cmd.aliases = vec!["new".to_string()];

        root.subcommands.insert("show".to_string(), show_cmd);
        root.subcommands.insert("search".to_string(), search_cmd);
        root.subcommands.insert("set-state".to_string(), set_state_cmd);
        root.subcommands.insert("dep".to_string(), dep_cmd);
        root.subcommands.insert("create".to_string(), create_cmd);

        let global_flags = vec![
            Flag {
                long: "db".to_string(),
                short: None,
                description: "Database path".to_string(),
                value_type: Some("string".to_string()),
                default: None,
            },
            Flag {
                long: "verbose".to_string(),
                short: Some('v'),
                description: "Enable verbose output".to_string(),
                value_type: None,
                default: None,
            },
            Flag {
                long: "help".to_string(),
                short: Some('h'),
                description: "help for bd".to_string(),
                value_type: None,
                default: None,
            },
        ];

        let mut tree = CommandTree::new(root);
        tree.global_flags = global_flags;
        tree.groups = vec![CommandGroup {
            name: "Working With Issues".to_string(),
            commands: vec!["show".to_string(), "search".to_string(), "create".to_string()],
        }];
        tree
    }

    #[test]
    fn test_generates_license_header() {
        let tree = sample_tree();
        let mut buf = Vec::new();
        generate_bash_completion(&tree, &mut buf).unwrap();
        let output = String::from_utf8(buf).unwrap();

        assert!(output.contains("Copyright 2006 JT Perry"));
        assert!(output.contains("Apache License, Version 2.0"));
    }

    #[test]
    fn test_generates_shebang() {
        let tree = sample_tree();
        let mut buf = Vec::new();
        generate_bash_completion(&tree, &mut buf).unwrap();
        let output = String::from_utf8(buf).unwrap();

        assert!(output.starts_with("#!/usr/bin/env bash"));
    }

    #[test]
    fn test_generates_complete_command() {
        let tree = sample_tree();
        let mut buf = Vec::new();
        generate_bash_completion(&tree, &mut buf).unwrap();
        let output = String::from_utf8(buf).unwrap();

        assert!(output.contains("complete -F _bd bd"));
    }

    #[test]
    fn test_completes_top_level_commands() {
        let tree = sample_tree();
        let mut buf = Vec::new();
        generate_bash_completion(&tree, &mut buf).unwrap();
        let output = String::from_utf8(buf).unwrap();

        // Should contain all subcommand names for top-level completion
        assert!(output.contains("create"));
        assert!(output.contains("dep"));
        assert!(output.contains("search"));
        assert!(output.contains("set-state"));
        assert!(output.contains("show"));
    }

    #[test]
    fn test_completes_subcommands() {
        let tree = sample_tree();
        let mut buf = Vec::new();
        generate_bash_completion(&tree, &mut buf).unwrap();
        let output = String::from_utf8(buf).unwrap();

        // dep should have add, remove, list subcommands
        assert!(output.contains("dep)"));
        assert!(output.contains("\"add list remove\""));
    }

    #[test]
    fn test_completes_flags() {
        let tree = sample_tree();
        let mut buf = Vec::new();
        generate_bash_completion(&tree, &mut buf).unwrap();
        let output = String::from_utf8(buf).unwrap();

        // Global flags should appear in flag completions
        assert!(output.contains("--db"));
        assert!(output.contains("--verbose"));
        assert!(output.contains("--help"));
    }

    #[test]
    fn test_completes_flag_values() {
        let tree = sample_tree();
        let mut buf = Vec::new();
        generate_bash_completion(&tree, &mut buf).unwrap();
        let output = String::from_utf8(buf).unwrap();

        // --db takes a file path, should use compgen -f
        assert!(output.contains("--db)"));
        assert!(output.contains("compgen -f"));
    }

    #[test]
    fn test_handles_aliases() {
        let tree = sample_tree();
        let mut buf = Vec::new();
        generate_bash_completion(&tree, &mut buf).unwrap();
        let output = String::from_utf8(buf).unwrap();

        // "create" has alias "new", both should be handled
        assert!(output.contains("create|new)"));
    }

    #[test]
    fn test_passes_shellcheck() {
        let tree = sample_tree();
        let mut buf = Vec::new();
        generate_bash_completion(&tree, &mut buf).unwrap();
        let script = String::from_utf8(buf).unwrap();

        // Write to temp file and run shellcheck
        let dir = std::env::temp_dir();
        let path = dir.join("bd_complete_test.bash");
        std::fs::write(&path, &script).unwrap();

        let output = std::process::Command::new("shellcheck")
            .arg(&path)
            .output();

        // Clean up
        let _ = std::fs::remove_file(&path);

        match output {
            Ok(result) => {
                let stderr = String::from_utf8_lossy(&result.stderr);
                let stdout = String::from_utf8_lossy(&result.stdout);
                assert!(
                    result.status.success(),
                    "shellcheck failed:\nstdout: {stdout}\nstderr: {stderr}\n\nScript:\n{script}"
                );
            }
            Err(e) => {
                // shellcheck not installed, skip
                eprintln!("shellcheck not available, skipping: {e}");
            }
        }
    }
}
