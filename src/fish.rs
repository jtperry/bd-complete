use crate::command_tree::{Command, CommandTree, Flag};
use std::io::{self, Write};

const LICENSE_HEADER: &str = r#"# Copyright 2006 JT Perry
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License."#;

/// Generate a complete Fish completion script for the given command tree.
pub fn generate_fish_completion(tree: &CommandTree, out: &mut dyn Write) -> io::Result<()> {
    writeln!(out, "{LICENSE_HEADER}")?;
    writeln!(out)?;
    writeln!(out, "# Fish completion for {}", tree.root.name)?;
    writeln!(out, "# Generated by bd-complete")?;
    writeln!(out)?;

    let cmd = &tree.root.name;

    // Disable file completions by default for the command
    writeln!(out, "complete -c {cmd} -f")?;
    writeln!(out)?;

    // Global flags
    if !tree.global_flags.is_empty() {
        writeln!(out, "# Global flags")?;
        for flag in &tree.global_flags {
            write_flag_completion(cmd, None, flag, out)?;
        }
        writeln!(out)?;
    }

    // Top-level subcommands
    generate_subcommand_completions(cmd, &tree.root, &tree.global_flags, out)?;

    Ok(())
}

/// Write completions for subcommands of a command, recursively.
fn generate_subcommand_completions(
    cmd: &str,
    parent: &Command,
    global_flags: &[Flag],
    out: &mut dyn Write,
) -> io::Result<()> {
    if parent.subcommands.is_empty() {
        return Ok(());
    }

    // Build the condition for "no subcommand yet" at this level
    let subcmd_names: Vec<&str> = parent
        .subcommands
        .iter()
        .flat_map(|(name, sub)| {
            let mut names = vec![name.as_str()];
            for alias in &sub.aliases {
                names.push(alias.as_str());
            }
            names
        })
        .collect();

    // Determine the condition for when these subcommands should be offered
    let condition = if parent.name == cmd {
        // Top-level: offer subcommands when no subcommand has been typed yet
        build_no_subcommand_condition(cmd, &subcmd_names)
    } else {
        // Nested: offer subcommands when parent command is present
        format!("__fish_seen_subcommand_from {}", parent.name)
    };

    // Register each subcommand
    for (name, subcmd) in &parent.subcommands {
        let desc = escape_description(&subcmd.description);
        writeln!(
            out,
            "complete -c {cmd} -n '{condition}' -a {name} -d '{desc}'"
        )?;

        // Register aliases as separate completions
        for alias in &subcmd.aliases {
            writeln!(
                out,
                "complete -c {cmd} -n '{condition}' -a {alias} -d '{desc}'"
            )?;
        }
    }
    writeln!(out)?;

    // Now generate flag completions and recurse for each subcommand
    for (name, subcmd) in &parent.subcommands {
        if !subcmd.flags.is_empty() {
            writeln!(out, "# Flags for '{name}'")?;
            for flag in &subcmd.flags {
                write_flag_completion(cmd, Some(name), flag, out)?;
            }
            writeln!(out)?;
        }

        // Recurse into sub-subcommands
        if !subcmd.subcommands.is_empty() {
            writeln!(out, "# Subcommands of '{name}'")?;
            generate_subcommand_completions(cmd, subcmd, global_flags, out)?;
        }
    }

    Ok(())
}

/// Build a condition string that checks no known subcommand has been seen yet.
fn build_no_subcommand_condition(_cmd: &str, subcmd_names: &[&str]) -> String {
    let names = subcmd_names.join(" ");
    format!("not __fish_seen_subcommand_from {names}")
}

/// Write a single `complete` line for a flag.
fn write_flag_completion(
    cmd: &str,
    subcmd: Option<&str>,
    flag: &Flag,
    out: &mut dyn Write,
) -> io::Result<()> {
    let desc = escape_description(&flag.description);
    let mut parts = vec![format!("complete -c {cmd}")];

    // Condition: if under a subcommand, require it to be seen
    if let Some(sub) = subcmd {
        parts.push(format!("-n '__fish_seen_subcommand_from {sub}'"));
    }

    // Long flag
    parts.push(format!("-l {}", flag.long));

    // Short flag
    if let Some(s) = flag.short {
        parts.push(format!("-s {s}"));
    }

    // If the flag takes a value, mark it as requiring an argument
    if flag.value_type.is_some() {
        parts.push("-r".to_string());

        // For file-like flags, enable file completion
        if flag.long.contains("file") || flag.long.contains("path") || flag.long == "db" {
            parts.push("-F".to_string());
        }
    }

    parts.push(format!("-d '{desc}'"));

    writeln!(out, "{}", parts.join(" "))
}

/// Escape single quotes in description for Fish shell.
fn escape_description(desc: &str) -> String {
    desc.replace('\'', "\\'")
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::command_tree::CommandGroup;

    fn sample_tree() -> CommandTree {
        let mut root = Command::new("bd", "A lightweight issue tracker");

        let mut show_cmd = Command::new("show", "Show issue details");
        show_cmd.flags.push(Flag {
            long: "format".to_string(),
            short: Some('f'),
            description: "Output format".to_string(),
            value_type: Some("string".to_string()),
            default: None,
        });

        let mut search_cmd = Command::new("search", "Search issues");
        search_cmd.flags.push(Flag {
            long: "query".to_string(),
            short: Some('q'),
            description: "Search query".to_string(),
            value_type: Some("string".to_string()),
            default: None,
        });

        let set_state_cmd = Command::new("set-state", "Set issue state");

        let mut dep_cmd = Command::new("dep", "Dependency management");
        dep_cmd.subcommands.insert(
            "add".to_string(),
            Command::new("add", "Add a dependency"),
        );
        dep_cmd.subcommands.insert(
            "remove".to_string(),
            Command::new("remove", "Remove a dependency"),
        );
        dep_cmd.subcommands.insert(
            "list".to_string(),
            Command::new("list", "List dependencies"),
        );

        let mut create_cmd = Command::new("create", "Create a new issue");
        create_cmd.aliases = vec!["new".to_string()];

        root.subcommands.insert("show".to_string(), show_cmd);
        root.subcommands.insert("search".to_string(), search_cmd);
        root.subcommands.insert("set-state".to_string(), set_state_cmd);
        root.subcommands.insert("dep".to_string(), dep_cmd);
        root.subcommands.insert("create".to_string(), create_cmd);

        let global_flags = vec![
            Flag {
                long: "db".to_string(),
                short: None,
                description: "Database path".to_string(),
                value_type: Some("string".to_string()),
                default: None,
            },
            Flag {
                long: "verbose".to_string(),
                short: Some('v'),
                description: "Enable verbose output".to_string(),
                value_type: None,
                default: None,
            },
            Flag {
                long: "help".to_string(),
                short: Some('h'),
                description: "help for bd".to_string(),
                value_type: None,
                default: None,
            },
        ];

        let mut tree = CommandTree::new(root);
        tree.global_flags = global_flags;
        tree.groups = vec![CommandGroup {
            name: "Working With Issues".to_string(),
            commands: vec!["show".to_string(), "search".to_string(), "create".to_string()],
        }];
        tree
    }

    #[test]
    fn test_generates_license_header() {
        let tree = sample_tree();
        let mut buf = Vec::new();
        generate_fish_completion(&tree, &mut buf).unwrap();
        let output = String::from_utf8(buf).unwrap();

        assert!(output.contains("Copyright 2006 JT Perry"));
        assert!(output.contains("Apache License, Version 2.0"));
    }

    #[test]
    fn test_uses_complete_c_bd() {
        let tree = sample_tree();
        let mut buf = Vec::new();
        generate_fish_completion(&tree, &mut buf).unwrap();
        let output = String::from_utf8(buf).unwrap();

        assert!(output.contains("complete -c bd"));
    }

    #[test]
    fn test_disables_file_completions() {
        let tree = sample_tree();
        let mut buf = Vec::new();
        generate_fish_completion(&tree, &mut buf).unwrap();
        let output = String::from_utf8(buf).unwrap();

        assert!(output.contains("complete -c bd -f"));
    }

    #[test]
    fn test_includes_command_descriptions() {
        let tree = sample_tree();
        let mut buf = Vec::new();
        generate_fish_completion(&tree, &mut buf).unwrap();
        let output = String::from_utf8(buf).unwrap();

        assert!(output.contains("-a show -d 'Show issue details'"));
        assert!(output.contains("-a search -d 'Search issues'"));
        assert!(output.contains("-a dep -d 'Dependency management'"));
    }

    #[test]
    fn test_completes_subcommands() {
        let tree = sample_tree();
        let mut buf = Vec::new();
        generate_fish_completion(&tree, &mut buf).unwrap();
        let output = String::from_utf8(buf).unwrap();

        // dep subcommands should be present
        assert!(output.contains("-a add -d 'Add a dependency'"));
        assert!(output.contains("-a remove -d 'Remove a dependency'"));
        assert!(output.contains("-a list -d 'List dependencies'"));
    }

    #[test]
    fn test_completes_flags_with_descriptions() {
        let tree = sample_tree();
        let mut buf = Vec::new();
        generate_fish_completion(&tree, &mut buf).unwrap();
        let output = String::from_utf8(buf).unwrap();

        // Global flags
        assert!(output.contains("-l db"));
        assert!(output.contains("-l verbose -s v"));
        assert!(output.contains("-l help -s h"));

        // Subcommand flags
        assert!(output.contains("-l format -s f"));
        assert!(output.contains("-l query -s q"));
    }

    #[test]
    fn test_flags_requiring_value_have_r() {
        let tree = sample_tree();
        let mut buf = Vec::new();
        generate_fish_completion(&tree, &mut buf).unwrap();
        let output = String::from_utf8(buf).unwrap();

        // --format takes a value, should have -r
        assert!(output.contains("-l format -s f -r"));
        // --verbose is boolean, should NOT have -r
        let verbose_line = output
            .lines()
            .find(|l| l.contains("-l verbose"))
            .unwrap();
        assert!(!verbose_line.contains(" -r"));
    }

    #[test]
    fn test_file_flags_get_file_completion() {
        let tree = sample_tree();
        let mut buf = Vec::new();
        generate_fish_completion(&tree, &mut buf).unwrap();
        let output = String::from_utf8(buf).unwrap();

        // --db is a file-like flag, should get -F
        let db_line = output.lines().find(|l| l.contains("-l db")).unwrap();
        assert!(db_line.contains("-F"));
    }

    #[test]
    fn test_handles_aliases() {
        let tree = sample_tree();
        let mut buf = Vec::new();
        generate_fish_completion(&tree, &mut buf).unwrap();
        let output = String::from_utf8(buf).unwrap();

        // "create" has alias "new"
        assert!(output.contains("-a create -d 'Create a new issue'"));
        assert!(output.contains("-a new -d 'Create a new issue'"));
    }

    #[test]
    fn test_subcommand_conditions() {
        let tree = sample_tree();
        let mut buf = Vec::new();
        generate_fish_completion(&tree, &mut buf).unwrap();
        let output = String::from_utf8(buf).unwrap();

        // Top-level subcommands should have "not __fish_seen_subcommand_from" condition
        assert!(output.contains("not __fish_seen_subcommand_from"));

        // dep subcommands should have "__fish_seen_subcommand_from dep" condition
        assert!(output.contains("__fish_seen_subcommand_from dep"));
    }
}
